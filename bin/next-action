#!/bin/bash

set -e

BATCH_SIZE=10
VERBOSE=false
MODEL=""

usage() {
    echo "Usage: next-action [options]"
    echo ""
    echo "Rewrite tasks as GTD next actions using an LLM."
    echo ""
    echo "Options:"
    echo "  -h, --help          Display this help message"
    echo "  -v, --verbose       Run with verbose output"
    echo "  -b, --batch SIZE    Process tasks in batches of SIZE (default: 10)"
    echo "  -m, --model MODEL   Specify LLM model to use (default: llm default)"
    echo ""
    echo "Example:"
    echo "  echo 'Update the website' | next-action"
    echo "  cat tasks.txt | next-action"
    exit 0
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -b|--batch)
            BATCH_SIZE="$2"
            shift 2
            ;;
        -m|--model)
            MODEL="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1" >&2
            usage
            ;;
    esac
done

# Check for stdin
if [ -t 0 ]; then
    echo "Error: Please pipe tasks to this command" >&2
    echo "Example: echo 'Update the website' | next-action" >&2
    echo "For multiple tasks: cat tasks.txt | next-action" >&2
    exit 1
fi

# Read all tasks from stdin into an array (portable version)
tasks=()
while IFS= read -r line; do
    [ -n "$line" ] && tasks+=("$line")
done

if [ ${#tasks[@]} -eq 0 ]; then
    echo "Error: No tasks received" >&2
    exit 1
fi

$VERBOSE && echo "Processing ${#tasks[@]} task(s) in batches of $BATCH_SIZE" >&2

SYSTEM_PROMPT='You are an expert in GTD (Getting Things Done) methodology.
Your task is to reword vague or complex tasks into clear, specific, physical next actions.

Guidelines for effective next actions:

1. Begin with a physical, visible action verb (e.g., "Call," "Email," "Draft," "Schedule")
2. Be specific about what needs to be done
3. Include enough context to act without needing more information
4. Focus on the very next physical action, not the overall project
5. If it requires less than 2 minutes, suggest doing it immediately

Examples:
- Vague: "Website update"
  Next action: "Draft list of specific website changes needed for homepage refresh"

- Vague: "Mom'\''s birthday"
  Next action: "Call flower shop at (555) 123-4567 to order arrangement for delivery on 5/15"

- Vague: "Follow up with client"
  Next action: "Email Alex at alex@example.com to request project timeline update"

- Vague: "Research vacation options"
  Next action: "Create Google Doc with 3 potential destinations and estimated costs for July trip"

Make your rewording concise, usually less than 140 characters, but specific.

For each numbered task I provide, reword it as a specific next action.
Return your answers with the same numbering, ensuring each response is on a new line.
Judge if each task is doable in less than 2 minutes (write "DO IT NOW" if so), is already an effectively worded next action (write "N/A" if so), or could be significantly improved with rewording.'

# Build model argument if specified
MODEL_ARG=""
if [ -n "$MODEL" ]; then
    MODEL_ARG="-m $MODEL"
fi

# Process tasks in batches
process_batch() {
    local formatted=""
    local i=1
    local task

    for task in "$@"; do
        formatted+="$i. $task"$'\n'
        i=$((i + 1))
    done

    $VERBOSE && echo "Processing batch of $# tasks..." >&2

    # Call llm with the system prompt and formatted tasks
    echo "$formatted" | llm $MODEL_ARG -s "$SYSTEM_PROMPT" --no-stream
}

# Process in batches and collect results
all_results=""
total=${#tasks[@]}
i=0
while [ $i -lt $total ]; do
    # Build batch array
    batch=()
    j=0
    while [ $j -lt $BATCH_SIZE ] && [ $((i + j)) -lt $total ]; do
        batch+=("${tasks[$((i + j))]}")
        j=$((j + 1))
    done

    result=$(process_batch "${batch[@]}")
    all_results+="$result"$'\n'
    i=$((i + BATCH_SIZE))
done

# Parse and display results
task_index=0
current_result=""

while IFS= read -r line; do
    # Check if line starts with a number followed by . or )
    if echo "$line" | grep -qE '^[[:space:]]*[0-9]+[.\)][[:space:]]+'; then
        # Output previous result if we have one
        if [ -n "$current_result" ] && [ $task_index -gt 0 ]; then
            if [ ${#tasks[@]} -gt 1 ]; then
                echo "Task $task_index:"
                $VERBOSE && echo "Original: ${tasks[$((task_index-1))]}"
                echo "Next action: $current_result"
                echo ""
            else
                echo "Next action: $current_result"
            fi
        fi
        task_index=$((task_index + 1))
        # Extract the content after the number
        current_result=$(echo "$line" | sed -E 's/^[[:space:]]*[0-9]+[.\)][[:space:]]+//')
    elif [ -n "$line" ]; then
        # Continue current result
        current_result="$current_result $line"
    fi
done <<< "$all_results"

# Output the last result
if [ -n "$current_result" ] && [ $task_index -gt 0 ]; then
    if [ ${#tasks[@]} -gt 1 ]; then
        echo "Task $task_index:"
        $VERBOSE && echo "Original: ${tasks[$((task_index-1))]}"
        echo "Next action: $current_result"
    else
        echo "Next action: $current_result"
    fi
fi
